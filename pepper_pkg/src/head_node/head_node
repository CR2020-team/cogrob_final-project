#!/usr/bin/python
"""
This node moves the robot head in the desidered position.
"""

import numpy as np
import rospy
from naoqi_driver.naoqi_node import NaoqiNode
from pepper_msgs.srv import TakePicture


class HeadNode(NaoqiNode):
    """Class used as an abstraction of the Node"""

    CAMERA_FOV = np.deg2rad(56.3)

    __slots__ = 'motionProxy'

    def __init__(self):
        """
        Constructor. Creates the node and connects it to the NaoQi interface.
        """
        NaoqiNode.__init__(self, 'head_node')
        self.connectNaoQi()

    def connectNaoQi(self):
        """
        Connects the node to the NaoQi interface. The parameters pip and pport are stored in the parameter server.
        The Proxy used is ALMotion, in order to make the robot head go to the desidered position
        when the service is called.
        """
        self.pip = rospy.get_param('pip')
        self.pport = rospy.get_param('pport')
        rospy.loginfo("HeadNode connecting to NaoQi at %s:%d", self.pip, self.pport)
        proxy = 'ALMotion'
        self.motionProxy = self.get_proxy(proxy)
        if self.motionProxy is None:
            raise rospy.ROSInitException('Unable to connect to {} proxy!'.format(proxy))
        rospy.loginfo("{} successful!".format(proxy))
        proxy = 'ALRobotPosture'
        self.postureProxy = self.get_proxy(proxy)
        if self.postureProxy is None:
            raise rospy.ROSInitException('Unable to connect to {} proxy!'.format(proxy))
        rospy.loginfo("{} successful!".format(proxy))

    def start(self):
        """
        Actual execution of the node.
        Creates the service server.
        """
        self.postureProxy.goToPosture("StandInit", 1.0)
        for direction in [-1, 0, 1]:
            # Look at right, front, left
            ret = self._look_at(direction)
            if not ret:
                raise rospy.ROSException('Unable to go to direction {}'.format(direction))
            # Take picture
            ret = self._take_picture(direction)
            if not ret:
                raise rospy.ROSException('Unable to take picture at direction {}'.format(direction))
            # Wait
            rospy.sleep(rospy.Duration(1.0))
        self.postureProxy.goToPosture("StandInit", 1.0)

    def _look_at(self, direction):
        """
        The handler of the service request.
        The request is the desidered head position (right, front, left) represented as integers (-1, 0, 1).
        The response is True when the position is reached (with an error less than 0.1 rad).
        """
        self.motionProxy.setStiffnesses("Head", 1.0)
        angles = {
            "HeadPitch": np.deg2rad(15),
            "HeadYaw": self.CAMERA_FOV * direction,
        }
        fractionMaxSpeed = 0.25
        self.motionProxy.setAngles(angles.keys(), angles.values(), fractionMaxSpeed)
        while True:
            currentAngles = self.motionProxy.getAngles(angles.keys(), True)
            if np.all(np.absolute(np.array(angles.values()) - np.array(currentAngles)) < 3e-2):
                break
        return True

    def _take_picture(self, direction):
        """
        Calls the TakePicture service.
        The request is the current direction.
        The response is the success of the service.
        """
        service = rospy.get_param('take_picture_service')
        rospy.wait_for_service(service)
        try:
            take_picture = rospy.ServiceProxy(service, TakePicture)
            return take_picture(direction).ready
        except rospy.ServiceException as exc:
            print("Service call failed: %s" % exc)
            return False


HeadNode().start()
try:
    rospy.spin()
except (KeyboardInterrupt, rospy.exceptions) as e:
    rospy.loginfo("shutdown: %s" % e)
